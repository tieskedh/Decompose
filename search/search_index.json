{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 What is Decompose? \u00b6 Decompose is a Kotlin Multiplatform library for breaking down your code into lifecycle-aware business logic components (aka BLoC), with routing functionality and pluggable UI (Jetpack Compose, Android Views, SwiftUI, JS React, etc.). Supported targets \u00b6 android , jvm js (both IR and Legacy modes) iosX64 , iosArm64 tvosArm64 , tvosX64 watchosArm32 , watchosArm64 , watchosX64 macosX64 Why Decompose? \u00b6 Decompose draws clear boundaries between UI and non-UI code, which gives the following benefits: Better separation of concerns Pluggable platform-specific UI (Compose, SwiftUI, React, etc.) Business logic code is testable with pure multiplatform unit tets Proper dependency injection (DI) and inversion of control (IoC) via constructor Shared navigation logic Lifecycle-aware components Components in the back stack are not destroyed, they continue working in background without UI Components and UI state preservation (mostly useful in Android) Instances retaining (aka ViewModels) over configuration changes (mostly useful in Android)","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#what-is-decompose","text":"Decompose is a Kotlin Multiplatform library for breaking down your code into lifecycle-aware business logic components (aka BLoC), with routing functionality and pluggable UI (Jetpack Compose, Android Views, SwiftUI, JS React, etc.).","title":"What is Decompose?"},{"location":"#supported-targets","text":"android , jvm js (both IR and Legacy modes) iosX64 , iosArm64 tvosArm64 , tvosX64 watchosArm32 , watchosArm64 , watchosX64 macosX64","title":"Supported targets"},{"location":"#why-decompose","text":"Decompose draws clear boundaries between UI and non-UI code, which gives the following benefits: Better separation of concerns Pluggable platform-specific UI (Compose, SwiftUI, React, etc.) Business logic code is testable with pure multiplatform unit tets Proper dependency injection (DI) and inversion of control (IoC) via constructor Shared navigation logic Lifecycle-aware components Components in the back stack are not destroyed, they continue working in background without UI Components and UI state preservation (mostly useful in Android) Instances retaining (aka ViewModels) over configuration changes (mostly useful in Android)","title":"Why Decompose?"},{"location":"samples/","text":"There are two sample apps: Counter and Todo List . Sample Counter App \u00b6 This sample demonstrates the following features: Nested components Routing Reused components State preservation (using StateKeeper ) Retaining instances (using InstanceKeeper ) Pluggable UI (Android Views, Jetpack Compose, SwiftUI, JS React) Content: shared - the module which includes the following components: Counter - this component just increments the counter every 250 ms. It starts counting once created and stops when destroyed. So Counter continues counting while in the back stack, unless recreated. It uses the InstanceKeeper , so counting continues after configuration changes. CounterInnerContainer - this component contains the Counter and two Routers on the left and on the right side. Each Router displays its stack of Counters and two buttons for navigation. \"Next\" button pushes another Counter to the corresponding Router , \"Prev\" button pops the active Counter for the Router . CounterRootComponent - this component contains the Counter , the Router of CounterInnerContainer and a button pushing another CounterInnerContainer to the stack. System back button is used for backward navigation. Android sample app iOS sample app JavaScript sample app Counter Component Structure \u00b6 Sample Todo List App \u00b6 The sample Todo List App demonstrates the following features: Multiplatform: Android, iOS, Desktop and Web Shared JetBrains Compose UI for Android and Desktop apps JetBrains Compose UI for the Web browser app SwiftUI for iOS app Nested components Shared routing with view state preservation Using Lifecycle Multi-module structure (one component per module) Inter-component communication (via Reaktive , just an example) MVI using MVIKotlin Data persistence using SQLDelight Please refer to the sample's readme for more information. Todo Source Code \u00b6 The sample Todo List App can be found in the JetBrains Compose repository here . Sample Master-Detail App \u00b6 \u26a0 This sample is for advanced single-pane/multi-pane navigation and layout, for generic master-detail navigation please refer to the Sample Todo List App described above. This sample demonstrates the following features: Advanced master-detail navigation with automatic single-pane/multi-pane layout Nested components Pluggable UI (Jetpack Compose for Android and Desktop, React for JS, more to come) Content: shared - the multiplatform module which includes the following components: ArticleList - the list of the items ArticleDetails - the details of the selected item Root - the root component navigating between screens compose-ui - the module containing Compose UI for Android and Desktop targets Android sample app Desktop sample app JavaScript sample app Sample Dynamic Features App \u00b6 This sample demonstrates the following features: Play Feature Delivery for Android Static features for JVM (Desktop) Nested components Routing Multi-module structure API and implementation modules for dynamic features Pluggable UI (JetBrains Compose) \u26a0 For testing purposes all dynamic features are configured as install-time Content: shared/feature1Api - API module for dynamic Feature1 component shared/feature1Impl - implementation module for dynamic Feature1 component shared/feature2Api - API module for dynamic Feature2 component shared/feature2Impl - implementation module for dynamic Feature2 component shared/main - the Main component which is displayed at start shared/root - the Root component which navigates between the child components Android sample app Desktop sample app Sample Greetings App \u00b6 Sample Greetings Repository Related articles \u00b6 Decompose \u2014 experiments with Kotlin Multiplatform lifecycle-aware components and navigation Fully cross-platform Kotlin applications (almost)","title":"Samples"},{"location":"samples/#sample-counter-app","text":"This sample demonstrates the following features: Nested components Routing Reused components State preservation (using StateKeeper ) Retaining instances (using InstanceKeeper ) Pluggable UI (Android Views, Jetpack Compose, SwiftUI, JS React) Content: shared - the module which includes the following components: Counter - this component just increments the counter every 250 ms. It starts counting once created and stops when destroyed. So Counter continues counting while in the back stack, unless recreated. It uses the InstanceKeeper , so counting continues after configuration changes. CounterInnerContainer - this component contains the Counter and two Routers on the left and on the right side. Each Router displays its stack of Counters and two buttons for navigation. \"Next\" button pushes another Counter to the corresponding Router , \"Prev\" button pops the active Counter for the Router . CounterRootComponent - this component contains the Counter , the Router of CounterInnerContainer and a button pushing another CounterInnerContainer to the stack. System back button is used for backward navigation. Android sample app iOS sample app JavaScript sample app","title":"Sample Counter App"},{"location":"samples/#counter-component-structure","text":"","title":"Counter Component Structure"},{"location":"samples/#sample-todo-list-app","text":"The sample Todo List App demonstrates the following features: Multiplatform: Android, iOS, Desktop and Web Shared JetBrains Compose UI for Android and Desktop apps JetBrains Compose UI for the Web browser app SwiftUI for iOS app Nested components Shared routing with view state preservation Using Lifecycle Multi-module structure (one component per module) Inter-component communication (via Reaktive , just an example) MVI using MVIKotlin Data persistence using SQLDelight Please refer to the sample's readme for more information.","title":"Sample Todo List App"},{"location":"samples/#todo-source-code","text":"The sample Todo List App can be found in the JetBrains Compose repository here .","title":"Todo Source Code"},{"location":"samples/#sample-master-detail-app","text":"\u26a0 This sample is for advanced single-pane/multi-pane navigation and layout, for generic master-detail navigation please refer to the Sample Todo List App described above. This sample demonstrates the following features: Advanced master-detail navigation with automatic single-pane/multi-pane layout Nested components Pluggable UI (Jetpack Compose for Android and Desktop, React for JS, more to come) Content: shared - the multiplatform module which includes the following components: ArticleList - the list of the items ArticleDetails - the details of the selected item Root - the root component navigating between screens compose-ui - the module containing Compose UI for Android and Desktop targets Android sample app Desktop sample app JavaScript sample app","title":"Sample Master-Detail App"},{"location":"samples/#sample-dynamic-features-app","text":"This sample demonstrates the following features: Play Feature Delivery for Android Static features for JVM (Desktop) Nested components Routing Multi-module structure API and implementation modules for dynamic features Pluggable UI (JetBrains Compose) \u26a0 For testing purposes all dynamic features are configured as install-time Content: shared/feature1Api - API module for dynamic Feature1 component shared/feature1Impl - implementation module for dynamic Feature1 component shared/feature2Api - API module for dynamic Feature2 component shared/feature2Impl - implementation module for dynamic Feature2 component shared/main - the Main component which is displayed at start shared/root - the Root component which navigates between the child components Android sample app Desktop sample app","title":"Sample Dynamic Features App"},{"location":"samples/#sample-greetings-app","text":"Sample Greetings Repository","title":"Sample Greetings App"},{"location":"samples/#related-articles","text":"Decompose \u2014 experiments with Kotlin Multiplatform lifecycle-aware components and navigation Fully cross-platform Kotlin applications (almost)","title":"Related articles"},{"location":"component/back-button/","text":"Back button handling \u00b6 Some devices (e.g. Android) have hardware back buttons. A very common use case is to close the current screen, or the app if there is only one screen in the stack. Another possible use case is to show a confirmation dialog before closing the app. Navigation with back button \u00b6 The Router can automatically navigate back when the back button is pressed. All you need to do is to supply the handleBackButton=true argument when you create the Router . Please see the related documentation page for more information. Manual back button handling \u00b6 The back button can be handled manually using BackPressedHandler (comes from Essenty library), which is provided by ComponentContext . The decompose module adds Essenty's back-pressed module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the BackPressedDispatcher . Usage example \u00b6 import com.arkivanov.decompose.ComponentContext class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { init { backPressedHandler . register ( :: onBackPressed ) } private fun onBackPressed (): Boolean { // Handle the back button. // Return true to consume the event, or false to allow other consumers. return false } }","title":"Back button"},{"location":"component/back-button/#back-button-handling","text":"Some devices (e.g. Android) have hardware back buttons. A very common use case is to close the current screen, or the app if there is only one screen in the stack. Another possible use case is to show a confirmation dialog before closing the app.","title":"Back button handling"},{"location":"component/back-button/#navigation-with-back-button","text":"The Router can automatically navigate back when the back button is pressed. All you need to do is to supply the handleBackButton=true argument when you create the Router . Please see the related documentation page for more information.","title":"Navigation with back button"},{"location":"component/back-button/#manual-back-button-handling","text":"The back button can be handled manually using BackPressedHandler (comes from Essenty library), which is provided by ComponentContext . The decompose module adds Essenty's back-pressed module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the BackPressedDispatcher .","title":"Manual back button handling"},{"location":"component/back-button/#usage-example","text":"import com.arkivanov.decompose.ComponentContext class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { init { backPressedHandler . register ( :: onBackPressed ) } private fun onBackPressed (): Boolean { // Handle the back button. // Return true to consume the event, or false to allow other consumers. return false } }","title":"Usage example"},{"location":"component/custom-component-context/","text":"Custom ComponentContext \u00b6 If one is needing ComponentContext to have extra functionality that is not already provided. It is possible to create a custom ComponentContext that could be decorated with the desired functionality of your choice. Create and implement custom ComponentContext \u00b6 For example, to create your own custom ComponentContext one must first create an interface that extends ComponentContext and then provide its implementation. interface AppComponentContext : ComponentContext { // Custom things here } class DefaultAppComponentContext ( componentContext : ComponentContext , // Additional dependencies here ) : AppComponentContext , ComponentContext by componentContext { // Custom things implementation here } How to create router with custom ComponentContext \u00b6 In order to pass this AppComponentContext to other components in an application from the Router , make an extension function on the AppComponentContext interface. This custom extension function will create the Router and provide child AppComponentContext . fun < C : Parcelable , T : Any > AppComponentContext . appRouter ( initialStack : () -> List < C > , configurationClass : KClass < out C > , key : String = \"DefaultRouter\" , handleBackButton : Boolean = false , childFactory : ( configuration : C , AppComponentContext ) -> T ): Router < C , T > = router ( initialStack = initialStack , configurationClass = configurationClass , key = key , handleBackButton = handleBackButton ) { configuration , componentContext -> childFactory ( configuration , DefaultAppComponentContext ( componentContext = componentContext ) ) } Finally, in your components you can create a new router that will utilize the new custom component context. class MyComponent ( componentContext : AppComponentContext ): AppComponentContext by componentContext { private val router = appRouter ( initialStack = { listOf ( Configuration . Home ) }, childFactory = { configuration , appComponentContext -> // return child components using the custom component context } ) }","title":"Custom ComponentContext"},{"location":"component/custom-component-context/#custom-componentcontext","text":"If one is needing ComponentContext to have extra functionality that is not already provided. It is possible to create a custom ComponentContext that could be decorated with the desired functionality of your choice.","title":"Custom ComponentContext"},{"location":"component/custom-component-context/#create-and-implement-custom-componentcontext","text":"For example, to create your own custom ComponentContext one must first create an interface that extends ComponentContext and then provide its implementation. interface AppComponentContext : ComponentContext { // Custom things here } class DefaultAppComponentContext ( componentContext : ComponentContext , // Additional dependencies here ) : AppComponentContext , ComponentContext by componentContext { // Custom things implementation here }","title":"Create and implement custom ComponentContext"},{"location":"component/custom-component-context/#how-to-create-router-with-custom-componentcontext","text":"In order to pass this AppComponentContext to other components in an application from the Router , make an extension function on the AppComponentContext interface. This custom extension function will create the Router and provide child AppComponentContext . fun < C : Parcelable , T : Any > AppComponentContext . appRouter ( initialStack : () -> List < C > , configurationClass : KClass < out C > , key : String = \"DefaultRouter\" , handleBackButton : Boolean = false , childFactory : ( configuration : C , AppComponentContext ) -> T ): Router < C , T > = router ( initialStack = initialStack , configurationClass = configurationClass , key = key , handleBackButton = handleBackButton ) { configuration , componentContext -> childFactory ( configuration , DefaultAppComponentContext ( componentContext = componentContext ) ) } Finally, in your components you can create a new router that will utilize the new custom component context. class MyComponent ( componentContext : AppComponentContext ): AppComponentContext by componentContext { private val router = appRouter ( initialStack = { listOf ( Configuration . Home ) }, childFactory = { configuration , appComponentContext -> // return child components using the custom component context } ) }","title":"How to create router with custom ComponentContext"},{"location":"component/instance-retaining/","text":"Instance retaining \u00b6 Sometimes it might be necessary to preserve state or data in a component when it gets destroyed. This commonly used in Android when configuration changes occur. The ComponentContext interface extends the InstanceKeeperOwner interface, which provides the InstanceKeeper - a multiplatform abstraction for instances retaining. It is provided by Essenty library (from the same author). The decompose module adds Essenty's instance-keeper module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the InstanceKeeper . Usage example \u00b6 import com.arkivanov.decompose.ComponentContext import com.arkivanov.essenty.instancekeeper.InstanceKeeper import com.arkivanov.essenty.instancekeeper.getOrCreate class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val someLogic = instanceKeeper . getOrCreate ( :: SomeLogic ) /* * Instances of this class will be retained. * \u26a0\ufe0f Pay attention to not leak any dependencies. */ private class SomeLogic : InstanceKeeper . Instance { override fun onDestroy () { // Clean-up } } }","title":"Instance retaining"},{"location":"component/instance-retaining/#instance-retaining","text":"Sometimes it might be necessary to preserve state or data in a component when it gets destroyed. This commonly used in Android when configuration changes occur. The ComponentContext interface extends the InstanceKeeperOwner interface, which provides the InstanceKeeper - a multiplatform abstraction for instances retaining. It is provided by Essenty library (from the same author). The decompose module adds Essenty's instance-keeper module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the InstanceKeeper .","title":"Instance retaining"},{"location":"component/instance-retaining/#usage-example","text":"import com.arkivanov.decompose.ComponentContext import com.arkivanov.essenty.instancekeeper.InstanceKeeper import com.arkivanov.essenty.instancekeeper.getOrCreate class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val someLogic = instanceKeeper . getOrCreate ( :: SomeLogic ) /* * Instances of this class will be retained. * \u26a0\ufe0f Pay attention to not leak any dependencies. */ private class SomeLogic : InstanceKeeper . Instance { override fun onDestroy () { // Clean-up } } }","title":"Usage example"},{"location":"component/lifecycle/","text":"Lifecycle \u00b6 The component lifecycle is very similar to the Android Activity lifecycle . The ComponentContext interface extends the LifecycleOwner interface, which provides the Lifecycle - a multiplatform abstraction for lifecycle states and events. It is provided by Essenty library (from the same author). The decompose module adds Essenty's lifecycle module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the Lifecycle . Each component has its own lifecycle. The lifecycle of a child component can not be longer than its parent's lifecycle. Usage example \u00b6 import com.arkivanov.decompose.ComponentContext import com.arkivanov.essenty.lifecycle.Lifecycle import com.arkivanov.essenty.lifecycle.doOnCreate import com.arkivanov.essenty.lifecycle.subscribe class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { init { lifecycle . subscribe ( object : Lifecycle . Callbacks { override fun onCreate () { /* Component created */ } // onStart, onResume, onPause, onStop, onDestroy } ) lifecycle . subscribe ( onCreate = { /* Component created */ }, // onStart, onResume, onPause, onStop, onDestroy ) lifecycle . doOnCreate { /* Component created */ } // doOnStart, doOnResume, doOnPause, doOnStop, doOnDestroy } }","title":"Lifecycle"},{"location":"component/lifecycle/#lifecycle","text":"The component lifecycle is very similar to the Android Activity lifecycle . The ComponentContext interface extends the LifecycleOwner interface, which provides the Lifecycle - a multiplatform abstraction for lifecycle states and events. It is provided by Essenty library (from the same author). The decompose module adds Essenty's lifecycle module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the Lifecycle . Each component has its own lifecycle. The lifecycle of a child component can not be longer than its parent's lifecycle.","title":"Lifecycle"},{"location":"component/lifecycle/#usage-example","text":"import com.arkivanov.decompose.ComponentContext import com.arkivanov.essenty.lifecycle.Lifecycle import com.arkivanov.essenty.lifecycle.doOnCreate import com.arkivanov.essenty.lifecycle.subscribe class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { init { lifecycle . subscribe ( object : Lifecycle . Callbacks { override fun onCreate () { /* Component created */ } // onStart, onResume, onPause, onStop, onDestroy } ) lifecycle . subscribe ( onCreate = { /* Component created */ }, // onStart, onResume, onPause, onStop, onDestroy ) lifecycle . doOnCreate { /* Component created */ } // doOnStart, doOnResume, doOnPause, doOnStop, doOnDestroy } }","title":"Usage example"},{"location":"component/overview/","text":"Component Overview \u00b6 A component is just a normal class that encapsulates some logic and possibly another (child) components. Every component has its own lifecycle, which is automatically managed by Decompose. So everything encapsulated by a component is scoped. Please head to the Lifecycle documentation page for more information. UI is optional and is pluggable from outside of components. Components do not depend on UI, the UI depends on components. Component hierarchy \u00b6 Pluggable UI hierarchy \u00b6 Typical component structure \u00b6 ComponentContext \u00b6 Each component has an associated ComponentContext which implements the following interfaces: LifecycleOwner , provided by Essenty library, so each component has its own lifecycle StateKeeperOwner , provided by Essenty library, so you can preserve any state during configuration changes and/or process death InstanceKeeperOwner , provided by Essenty library, so you can retain arbitrary object instances in your components (like with AndroidX ViewModels) BackPressedDispatcherOwner , provided by Essenty library, so each component can handle back button events So if a component requires any of the above features, just pass the ComponentContext via the component's constructor. You can use the delegation pattern to add the ComponentContext to this scope: class Counter ( componentContext : ComponentContext ) : ComponentContext by componentContext { // The rest of the code } Root ComponentContext \u00b6 When instantiating a root component, the ComponentContext should be created manually. There is DefaultComponentContext which is the default implementation class of the ComponentContext . Root ComponentContext in Android \u00b6 Decompose provides a few handy helper functions for creating the root ComponentContext in Android. The preferred way is to create the root ComponentContext in an Activity or a Fragment . Root ComponentContext in Activity \u00b6 For this case Decompose provides defaultComponentContext() extension function, which can be called in scope of an Activity . Root ComponentContext in Fragment \u00b6 The defaultComponentContext() extension function can not be used in a Fragment. This is because the Fragment class does not implement the OnBackPressedDispatcherOwner interface, and so by default can't handle back button events. It is advised to use the Android-specific DefaultComponentContext(AndroidLifecycle, SavedStateRegistry?, ViewModelStore?, OnBackPressedDispatcher?) factory function, and supply all the arguments manually. The first three arguments ( AndroidLifecycle , SavedStateRegistry and ViewModelStore ) can be obtained directly from Fragment . However the last argument OnBackPressedDispatcher - can not. If you don't need to handle back button events in your Decompose components, then you can just ignore this argument. Otherwise, a manual solution is required. \u26a0\ufe0f Don't take any argument values from the hosting Activity (e.g. requireActivity().onBackPressedDispatcher ), as it may produce memory leaks. Here is an example with using Decompose in a DialogFragment . class MyFragment : DialogFragment () { // Create custom OnBackPressedDispatcher private val onBackPressedDispatcher = OnBackPressedDispatcher ( :: dismiss ) private lateinit var root : Root override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) root = Root ( DefaultComponentContext ( lifecycle = lifecycle , savedStateRegistry = savedStateRegistry , viewModelStore = viewModelStore , onBackPressedDispatcher = onBackPressedDispatcher , ) ) } override fun onCreateDialog ( savedInstanceState : Bundle?) : Dialog = object : Dialog ( requireContext (), theme ) { override fun onBackPressed () { onBackPressedDispatcher . onBackPressed () } } override fun onCreateView ( inflater : LayoutInflater , container : ViewGroup?, savedInstanceState : Bundle?) : View = // Start Compose here } Root ComponentContext in Jetpack/JetBrains Compose \u00b6 It is advised to not create the root ComponentContext (and a root component) directly in a Composable function. Compositions may be performed in a background thread, which may brake things. The preferred way is to create the root component outside of Compose. \u26a0\ufe0f If you can't avoid creating the root component in a Composable function, please make sure you use remember . This will prevent the root component and its ComponentContext from being recreated on each composition. Android with Compose \u00b6 Prefer creating the root ComponentContext (and a root component) before starting Compose, e.g. in an Activity or a Fragment . class MainActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) // Create the root component before starting Compose val root = RootComponent ( componentContext = defaultComponentContext ()) // Start Compose setContent { // The rest of the code } } } Other platforms with Compose \u00b6 Prefer creating the root ComponentContext (and a root component) before starting Compose, e.g. in directly in the main function. fun main () { // Create the root component before starting Compose val root = RootComponent ( componentContext = DefaultComponentContext (...)) // Start Compose application { // The rest of the code } } Child components \u00b6 Decompose provides ability to organize components into trees, so each parent component is only aware of its immediate children. Hence the name of the library - \"Decompose\". You decompose your project by multiple independent reusable components. When adding a sub-tree into another place (reusing), you only need to satisfy its top component's dependencies. There are two common ways to add a child component: Using the Router - prefer this option when a navigation between components is required. Please head to the Router documentation page for more information. Manually - prefer this option if you need to add a permanent child component, or to manually control its Lifecycle . Adding a child component manually \u00b6 In order to add a child component manually, you need to create a separate child ComponentContext for it. There is ComponentContext.childContext(key: String, lifecycle: Lifecycle? = null) extension function provided by the library, which creates a new instance of ComponentContext and attaches it to the parent one. This function has two arguments: key - A key of the child ComponentContext , must be unique within the parent ComponentContext lifecycle - An optional Lifecycle of the child ComponentContext , can be used if the child component needs to be destroyed earlier, or if you need manual control. If supplied, then the following conditions apply: the resulting Lifecycle of the child component will honour both the parent Lifecycle and the supplied one when the supplied Lifecycle is explicitly destroyed, the child ComponentContext detaches from its parent Here is an example of creating a permanent child component: class SomeParent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val counter : Counter = Counter ( childContext ( key = \"Counter\" )) } Here is an example of creating a child component with manual lifecycle: class SomeParent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private var counterHolder : CounterHolder? = null fun createCounter () { val lifecycle = LifecycleRegistry () val counter = Counter ( childContext ( key = \"Counter\" , lifecycle = lifecycle )) lifecycle . resume () counterHolder = CounterHolder ( counter , lifecycle ) } fun destroyCounter () { counterHolder ?. lifecycle ?. destroy () counterHolder = null } private class CounterHolder ( val counter : Counter , val lifecycle : LifecycleRegistry , ) } \u26a0\ufe0f Never pass parent's ComponentContext to children, always use either the Router or the childContext(...) function. Examples \u00b6 Simplest Component Example \u00b6 Here is an example of simple Counter component: class Counter { private val _value = MutableValue ( State ()) val state : Value < State > = _value fun increment () { _value . reduce { it . copy ( count = it . count + 1 ) } } data class State ( val count : Int = 0 ) } Jetpack/JetBrains Compose UI Example \u00b6 @Composable fun CounterUi ( counter : Counter ) { val state by counter . state . subscribeAsState () Column { Text ( text = state . count . toString ()) Button ( onClick = counter :: increment ) { Text ( \"Increment\" ) } } } Value - is a multiplatform way to expose streams of states. It contains the value property, which always returns the current state. It also provides ability to observe state changes via subscribe / unsubscribe methods. There is MutableValue which is a mutable variant of Value . If you are using only Jetpack/JetBrains Compose UI, then most likely you can use its State and MutableState directly, without intermediate Value / MutableValue from Decompose. You can convert between State and Value using one of the Compose extension modules . SwiftUI Example \u00b6 struct CounterView : View { private let counter : Counter @ ObservedObject private var state : ObservableValue < CounterState > init ( _ counter : Counter ) { self . counter = counter self . state = ObservableValue ( counter . state ) } var body : some View { VStack ( spacing : 8 ) { Text ( self . state . value . text ) Button ( action : self . counter . increment , label : { Text ( \"Increment\" ) }) } } }","title":"Overview"},{"location":"component/overview/#component-overview","text":"A component is just a normal class that encapsulates some logic and possibly another (child) components. Every component has its own lifecycle, which is automatically managed by Decompose. So everything encapsulated by a component is scoped. Please head to the Lifecycle documentation page for more information. UI is optional and is pluggable from outside of components. Components do not depend on UI, the UI depends on components.","title":"Component Overview"},{"location":"component/overview/#component-hierarchy","text":"","title":"Component hierarchy"},{"location":"component/overview/#pluggable-ui-hierarchy","text":"","title":"Pluggable UI hierarchy"},{"location":"component/overview/#typical-component-structure","text":"","title":"Typical component structure"},{"location":"component/overview/#componentcontext","text":"Each component has an associated ComponentContext which implements the following interfaces: LifecycleOwner , provided by Essenty library, so each component has its own lifecycle StateKeeperOwner , provided by Essenty library, so you can preserve any state during configuration changes and/or process death InstanceKeeperOwner , provided by Essenty library, so you can retain arbitrary object instances in your components (like with AndroidX ViewModels) BackPressedDispatcherOwner , provided by Essenty library, so each component can handle back button events So if a component requires any of the above features, just pass the ComponentContext via the component's constructor. You can use the delegation pattern to add the ComponentContext to this scope: class Counter ( componentContext : ComponentContext ) : ComponentContext by componentContext { // The rest of the code }","title":"ComponentContext"},{"location":"component/overview/#root-componentcontext","text":"When instantiating a root component, the ComponentContext should be created manually. There is DefaultComponentContext which is the default implementation class of the ComponentContext .","title":"Root ComponentContext"},{"location":"component/overview/#root-componentcontext-in-android","text":"Decompose provides a few handy helper functions for creating the root ComponentContext in Android. The preferred way is to create the root ComponentContext in an Activity or a Fragment .","title":"Root ComponentContext in Android"},{"location":"component/overview/#root-componentcontext-in-activity","text":"For this case Decompose provides defaultComponentContext() extension function, which can be called in scope of an Activity .","title":"Root ComponentContext in Activity"},{"location":"component/overview/#root-componentcontext-in-fragment","text":"The defaultComponentContext() extension function can not be used in a Fragment. This is because the Fragment class does not implement the OnBackPressedDispatcherOwner interface, and so by default can't handle back button events. It is advised to use the Android-specific DefaultComponentContext(AndroidLifecycle, SavedStateRegistry?, ViewModelStore?, OnBackPressedDispatcher?) factory function, and supply all the arguments manually. The first three arguments ( AndroidLifecycle , SavedStateRegistry and ViewModelStore ) can be obtained directly from Fragment . However the last argument OnBackPressedDispatcher - can not. If you don't need to handle back button events in your Decompose components, then you can just ignore this argument. Otherwise, a manual solution is required. \u26a0\ufe0f Don't take any argument values from the hosting Activity (e.g. requireActivity().onBackPressedDispatcher ), as it may produce memory leaks. Here is an example with using Decompose in a DialogFragment . class MyFragment : DialogFragment () { // Create custom OnBackPressedDispatcher private val onBackPressedDispatcher = OnBackPressedDispatcher ( :: dismiss ) private lateinit var root : Root override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) root = Root ( DefaultComponentContext ( lifecycle = lifecycle , savedStateRegistry = savedStateRegistry , viewModelStore = viewModelStore , onBackPressedDispatcher = onBackPressedDispatcher , ) ) } override fun onCreateDialog ( savedInstanceState : Bundle?) : Dialog = object : Dialog ( requireContext (), theme ) { override fun onBackPressed () { onBackPressedDispatcher . onBackPressed () } } override fun onCreateView ( inflater : LayoutInflater , container : ViewGroup?, savedInstanceState : Bundle?) : View = // Start Compose here }","title":"Root ComponentContext in Fragment"},{"location":"component/overview/#root-componentcontext-in-jetpackjetbrains-compose","text":"It is advised to not create the root ComponentContext (and a root component) directly in a Composable function. Compositions may be performed in a background thread, which may brake things. The preferred way is to create the root component outside of Compose. \u26a0\ufe0f If you can't avoid creating the root component in a Composable function, please make sure you use remember . This will prevent the root component and its ComponentContext from being recreated on each composition.","title":"Root ComponentContext in Jetpack/JetBrains Compose"},{"location":"component/overview/#android-with-compose","text":"Prefer creating the root ComponentContext (and a root component) before starting Compose, e.g. in an Activity or a Fragment . class MainActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) // Create the root component before starting Compose val root = RootComponent ( componentContext = defaultComponentContext ()) // Start Compose setContent { // The rest of the code } } }","title":"Android with Compose"},{"location":"component/overview/#other-platforms-with-compose","text":"Prefer creating the root ComponentContext (and a root component) before starting Compose, e.g. in directly in the main function. fun main () { // Create the root component before starting Compose val root = RootComponent ( componentContext = DefaultComponentContext (...)) // Start Compose application { // The rest of the code } }","title":"Other platforms with Compose"},{"location":"component/overview/#child-components","text":"Decompose provides ability to organize components into trees, so each parent component is only aware of its immediate children. Hence the name of the library - \"Decompose\". You decompose your project by multiple independent reusable components. When adding a sub-tree into another place (reusing), you only need to satisfy its top component's dependencies. There are two common ways to add a child component: Using the Router - prefer this option when a navigation between components is required. Please head to the Router documentation page for more information. Manually - prefer this option if you need to add a permanent child component, or to manually control its Lifecycle .","title":"Child components"},{"location":"component/overview/#adding-a-child-component-manually","text":"In order to add a child component manually, you need to create a separate child ComponentContext for it. There is ComponentContext.childContext(key: String, lifecycle: Lifecycle? = null) extension function provided by the library, which creates a new instance of ComponentContext and attaches it to the parent one. This function has two arguments: key - A key of the child ComponentContext , must be unique within the parent ComponentContext lifecycle - An optional Lifecycle of the child ComponentContext , can be used if the child component needs to be destroyed earlier, or if you need manual control. If supplied, then the following conditions apply: the resulting Lifecycle of the child component will honour both the parent Lifecycle and the supplied one when the supplied Lifecycle is explicitly destroyed, the child ComponentContext detaches from its parent Here is an example of creating a permanent child component: class SomeParent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val counter : Counter = Counter ( childContext ( key = \"Counter\" )) } Here is an example of creating a child component with manual lifecycle: class SomeParent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private var counterHolder : CounterHolder? = null fun createCounter () { val lifecycle = LifecycleRegistry () val counter = Counter ( childContext ( key = \"Counter\" , lifecycle = lifecycle )) lifecycle . resume () counterHolder = CounterHolder ( counter , lifecycle ) } fun destroyCounter () { counterHolder ?. lifecycle ?. destroy () counterHolder = null } private class CounterHolder ( val counter : Counter , val lifecycle : LifecycleRegistry , ) } \u26a0\ufe0f Never pass parent's ComponentContext to children, always use either the Router or the childContext(...) function.","title":"Adding a child component manually"},{"location":"component/overview/#examples","text":"","title":"Examples"},{"location":"component/overview/#simplest-component-example","text":"Here is an example of simple Counter component: class Counter { private val _value = MutableValue ( State ()) val state : Value < State > = _value fun increment () { _value . reduce { it . copy ( count = it . count + 1 ) } } data class State ( val count : Int = 0 ) }","title":"Simplest Component Example"},{"location":"component/overview/#jetpackjetbrains-compose-ui-example","text":"@Composable fun CounterUi ( counter : Counter ) { val state by counter . state . subscribeAsState () Column { Text ( text = state . count . toString ()) Button ( onClick = counter :: increment ) { Text ( \"Increment\" ) } } } Value - is a multiplatform way to expose streams of states. It contains the value property, which always returns the current state. It also provides ability to observe state changes via subscribe / unsubscribe methods. There is MutableValue which is a mutable variant of Value . If you are using only Jetpack/JetBrains Compose UI, then most likely you can use its State and MutableState directly, without intermediate Value / MutableValue from Decompose. You can convert between State and Value using one of the Compose extension modules .","title":"Jetpack/JetBrains Compose UI Example"},{"location":"component/overview/#swiftui-example","text":"struct CounterView : View { private let counter : Counter @ ObservedObject private var state : ObservableValue < CounterState > init ( _ counter : Counter ) { self . counter = counter self . state = ObservableValue ( counter . state ) } var body : some View { VStack ( spacing : 8 ) { Text ( self . state . value . text ) Button ( action : self . counter . increment , label : { Text ( \"Increment\" ) }) } } }","title":"SwiftUI Example"},{"location":"component/state-preservation/","text":"State preservation \u00b6 Sometimes it might be necessary to preserve state or data in a component when it gets destroyed. A very common use case is Android Activity recreation due to configuration changes, or process death. The ComponentContext interface extends the StateKeeperOwner interface, which provides the StateKeeper - a multiplatform abstraction for state preservation. It is provided by Essenty library (from the same author). The decompose module adds Essenty's state-keeper module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the StateKeeper . Usage example \u00b6 import com.arkivanov.decompose.ComponentContext import com.arkivanov.essenty.parcelable.Parcelable import com.arkivanov.essenty.parcelable.Parcelize import com.arkivanov.essenty.statekeeper.consume class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private var state : State = stateKeeper . consume ( key = \"SAVED_STATE\" ) ?: State () init { stateKeeper . register ( key = \"SAVED_STATE\" ) { state } } @Parcelize private class State ( val someValue : Int = 0 ) : Parcelable }","title":"State preservation"},{"location":"component/state-preservation/#state-preservation","text":"Sometimes it might be necessary to preserve state or data in a component when it gets destroyed. A very common use case is Android Activity recreation due to configuration changes, or process death. The ComponentContext interface extends the StateKeeperOwner interface, which provides the StateKeeper - a multiplatform abstraction for state preservation. It is provided by Essenty library (from the same author). The decompose module adds Essenty's state-keeper module as api dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the StateKeeper .","title":"State preservation"},{"location":"component/state-preservation/#usage-example","text":"import com.arkivanov.decompose.ComponentContext import com.arkivanov.essenty.parcelable.Parcelable import com.arkivanov.essenty.parcelable.Parcelize import com.arkivanov.essenty.statekeeper.consume class SomeComponent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private var state : State = stateKeeper . consume ( key = \"SAVED_STATE\" ) ?: State () init { stateKeeper . register ( key = \"SAVED_STATE\" ) { state } } @Parcelize private class State ( val someValue : Int = 0 ) : Parcelable }","title":"Usage example"},{"location":"extensions/android/","text":"Extensions for Android views \u00b6 Experimental extensions and utilities for easier integration of Decompose with Android views. Setup \u00b6 Extensions for Android views are provided by the extensions-android module. Groovy implementation \"com.arkivanov.decompose:extensions-android:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-android:<version>\" ) Content \u00b6 Decompose is primarily designed for better integration with declarative UI frameworks, such as Jetpack/JetBrains Compose, SwiftUI, React, etc. However it still can be used with Android views. Because the main Decompose functionality is separate from UI, the latter has to be plugged externally. This module provides some essential extensions and utilities to improve the experience. ViewContext \u00b6 As mentioned before, Decompose is not aware of any UI. Because the UI is plugged externally, it needs its own Lifecycle . The idea is to supply every view sub-tree with ViewContext , which exposes the following properties: parent - a ViewGroup where the view sub-tree should be inflated lifecycle - a Lifecycle of the view sub-tree The following ViewContext extensions are available: val ViewContext.context: Context - returns the Android Context of the view sub-tree val ViewContext.resources: Resources - returns the Android Resources of the view sub-tree val ViewContext.layoutInflater: LayoutInflater - returns the Android LayoutInflater fun ViewContext.child(ViewGroup, inflater): ViewContext - creates a child ViewContext with another parent ViewGroup , which shares the Lifecycle of the parent ViewContext . The inflater arguments should inflate a sub-tree of views, but without adding it to the parent . DefaultViewContext - is a default implementation of ViewContext , which can be used to manually create new instances when needed. RouterView \u00b6 RouterView is an Android ViewGroup which observes the Router and manages child views. Once RouterView is added to the view hierarchy, just call its children(...) method with the following arguments: routerState - the observable Value of RouterState , typically the Router.state property lifecycle - the lifecycle of the RouterView or its closest parent replaceChildView - a function which replaces a currently active child view with a new one, this is also the place where transitions can be applied Examples \u00b6 You can find an example of using this extensions module in the Counter sample. Initializing the root in Activity : override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . main_activity ) val root = CounterRootComponent ( defaultComponentContext ()) val viewContext = DefaultViewContext ( parent = findViewById ( R . id . content ), lifecycle = essentyLifecycle () ) viewContext . apply { child ( parent ) { CounterRootView ( root ) } } } A simple child view: fun ViewContext . CounterView ( counter : Counter ): View { // Inflate the layout without adding it to the parent val layout = layoutInflater . inflate ( R . layout . counter , parent , false ) // Find required views val counterText : TextView = layout . findViewById ( R . id . text_count ) // Observe Counter models and update the view counter . model . observe ( lifecycle ) { data -> counterText . text = data . text } return layout // Return the root of the inflated sub-tree } RouterView example: fun ViewContext . CounterRootView ( counterRoot : CounterRoot ): View { val layout = layoutInflater . inflate ( R . layout . counter_root , parent , false ) val nextButton : View = layout . findViewById ( R . id . button_next ) val router : RouterView = layout . findViewById ( R . id . router ) nextButton . setOnClickListener { counterRoot . onNextChild () } // Create a child `ViewContext` for the inner `CounterView` child ( layout . findViewById ( R . id . container_counter )) { // Reuse the `CounterView` CounterView ( counterRoot . counter ) } // Subscribe the `RouterView` to the `Router` router . children ( counterRoot . routerState , lifecycle ) { parent , child , _ -> // Remove all existing views parent . removeAllViews () // Add the child view for the currently active child component parent . addView ( CounterInnerView ( child . inner )) } return layout }","title":"Extensions for Android views"},{"location":"extensions/android/#extensions-for-android-views","text":"Experimental extensions and utilities for easier integration of Decompose with Android views.","title":"Extensions for Android views"},{"location":"extensions/android/#setup","text":"Extensions for Android views are provided by the extensions-android module. Groovy implementation \"com.arkivanov.decompose:extensions-android:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-android:<version>\" )","title":"Setup"},{"location":"extensions/android/#content","text":"Decompose is primarily designed for better integration with declarative UI frameworks, such as Jetpack/JetBrains Compose, SwiftUI, React, etc. However it still can be used with Android views. Because the main Decompose functionality is separate from UI, the latter has to be plugged externally. This module provides some essential extensions and utilities to improve the experience.","title":"Content"},{"location":"extensions/android/#viewcontext","text":"As mentioned before, Decompose is not aware of any UI. Because the UI is plugged externally, it needs its own Lifecycle . The idea is to supply every view sub-tree with ViewContext , which exposes the following properties: parent - a ViewGroup where the view sub-tree should be inflated lifecycle - a Lifecycle of the view sub-tree The following ViewContext extensions are available: val ViewContext.context: Context - returns the Android Context of the view sub-tree val ViewContext.resources: Resources - returns the Android Resources of the view sub-tree val ViewContext.layoutInflater: LayoutInflater - returns the Android LayoutInflater fun ViewContext.child(ViewGroup, inflater): ViewContext - creates a child ViewContext with another parent ViewGroup , which shares the Lifecycle of the parent ViewContext . The inflater arguments should inflate a sub-tree of views, but without adding it to the parent . DefaultViewContext - is a default implementation of ViewContext , which can be used to manually create new instances when needed.","title":"ViewContext"},{"location":"extensions/android/#routerview","text":"RouterView is an Android ViewGroup which observes the Router and manages child views. Once RouterView is added to the view hierarchy, just call its children(...) method with the following arguments: routerState - the observable Value of RouterState , typically the Router.state property lifecycle - the lifecycle of the RouterView or its closest parent replaceChildView - a function which replaces a currently active child view with a new one, this is also the place where transitions can be applied","title":"RouterView"},{"location":"extensions/android/#examples","text":"You can find an example of using this extensions module in the Counter sample. Initializing the root in Activity : override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . main_activity ) val root = CounterRootComponent ( defaultComponentContext ()) val viewContext = DefaultViewContext ( parent = findViewById ( R . id . content ), lifecycle = essentyLifecycle () ) viewContext . apply { child ( parent ) { CounterRootView ( root ) } } } A simple child view: fun ViewContext . CounterView ( counter : Counter ): View { // Inflate the layout without adding it to the parent val layout = layoutInflater . inflate ( R . layout . counter , parent , false ) // Find required views val counterText : TextView = layout . findViewById ( R . id . text_count ) // Observe Counter models and update the view counter . model . observe ( lifecycle ) { data -> counterText . text = data . text } return layout // Return the root of the inflated sub-tree } RouterView example: fun ViewContext . CounterRootView ( counterRoot : CounterRoot ): View { val layout = layoutInflater . inflate ( R . layout . counter_root , parent , false ) val nextButton : View = layout . findViewById ( R . id . button_next ) val router : RouterView = layout . findViewById ( R . id . router ) nextButton . setOnClickListener { counterRoot . onNextChild () } // Create a child `ViewContext` for the inner `CounterView` child ( layout . findViewById ( R . id . container_counter )) { // Reuse the `CounterView` CounterView ( counterRoot . counter ) } // Subscribe the `RouterView` to the `Router` router . children ( counterRoot . routerState , lifecycle ) { parent , child , _ -> // Remove all existing views parent . removeAllViews () // Add the child view for the currently active child component parent . addView ( CounterInnerView ( child . inner )) } return layout }","title":"Examples"},{"location":"extensions/compose/","text":"Extensions for Jetpack/JetBrains Compose \u00b6 Extensions and utilities for easier integration of Decompose with Jetpack/JetBrains Compose. Setup \u00b6 Since Jetpack and JetBrains Compose are published separately into different repositories, Decompose provides separate modules for each variant. Both modules provide similar functionality, but you need to choose the corresponding module depending on the used Compose variant. Setup extensions for Jetpack Compose \u00b6 Extensions for Jetpack Compose are provided by the extensions-compose-jetpack module. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" ) Setup extensions for JetBrains Compose \u00b6 Extensions for JetBrains Compose are provided by the extensions-compose-jetbrains module. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" ) Content \u00b6 As mentioned above both modules provide similar functionality. Most of the links in this document refer to the Jetpack module, however there usually a mirror in the JetBrains module. Converting Value to State \u00b6 To convert Decompose Value to Compose State use Value<T>.subscribeAsState(): State<T> extensions function: interface SomeComponent { val models : Value < Model > data class Model ( /*...*/ ) } @Composable fun SomeContent ( component : SomeComponent ) { val models : State < Model > by component . models . subscribeAsState () } Controlling the Lifecycle on Desktop \u00b6 When using JetBrains Compose, you can have a LifecycleRegistry react to changes in the window state using the LifecycleController() composable. This will trigger appropriate lifecycle events when the window is minimized, restored or closed. It is also possible to manually start the lifecycle using LifecycleRegistry.resume() when the instance is created. fun main () { val lifecycle = LifecycleRegistry () val root = RootComponent ( DefaultComponentContext ( lifecycle )) // Alternative: manually start the lifecycle (no reaction to window state) // lifecycle.resume() application { val windowState = rememberWindowState () // Bind the registry to the life cycle of the window LifecycleController ( lifecycle , windowState ) Window ( state = windowState , ...) { // The rest of your content } } } \u26a0\ufe0f When using Compose in desktop platforms, make sure to always use one of the methods above, or your components might not receive lifecycle events correctly. Navigating between Composable components \u00b6 The Router provides the RouterState as Value<RouterState> which can be observed in a Composable component. This makes it possible to switch child Composable components following the Router . Both Compose extension modules provide the Children(...) function which has the following features: It listens for the RouterState changes and displays the corresponding child Composable component using the provided slot lambda. It preserves components' UI state (e.g. scrolling position) in the back stack and over configuration changes and process death. It animates between children if there is an animation spec provided. Here is an example of switching child components on navigation: // Root interface RootComponent { val routerState : Value < RouterState <* , Child >> sealed class Child { data class Main ( val component : MainComponent ) : Child () data class Details ( val component : DetailsComponent ) : Child () } } @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( rootComponent . routerState ) { when ( val child = it . instance ) { is RootComponent . Child . Main -> MainContent ( child . component ) is RootComponent . Child . Details -> DetailsContent ( child . component ) } } } // Children interface MainComponent interface DetailsComponent @Composable fun MainContent ( profileComponent : MainComponent ) { // Omitted code } @Composable fun DetailsContent ( settingsComponent : DetailsComponent ) { // Omitted code } Animations (experimental) \u00b6 Decompose provides the Child Animation API for Compose, as well as some predefined animation specs. To enable child animations you need to pass the animation argument to the Children function. There are predefined animators provided by Decompose. Fade animation \u00b6 @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = childAnimation ( fade ()) ) { // Omitted code } } Slide animation \u00b6 @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = childAnimation ( slide ()) ) { // Omitted code } } Combining animators \u00b6 It is also possible to combine animators using the plus operator. Please note that the order matters - the right animator is applied after the left animator. @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = childAnimation ( fade () + scale ()) ) { // Omitted code } } Separate animations for children \u00b6 Previous examples demonstrate simple cases, when all children have the same animation. But it is also possible to specify separate animations for children. @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = childAnimation { child , direction -> when ( child . instance ) { is RootComponent . Child . Main -> fade () + scale () is RootComponent . Child . Details -> fade () + slide () } } ) { // Omitted code } } Custom animations \u00b6 It is also possible to define custom animations. Implementing ChildAnimation manually. This is the most flexible low-level API. The animation block receives the current RouterState and animates children using the provided content slot. @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = someAnimation () ) { // Omitted code } } fun < C : Any , T : Any > someAnimation (): ChildAnimation < C , T > = ChildAnimation { routerState : RouterState < C , T > , modifier : Modifier , content : @Composable ( Child . Created < C , T > ) -> Unit -> // Render each frame here } Using the childAnimation helper function and implementing ChildAnimator . The childAnimation function takes care of tracking the RouterState changes. ChildAnimator is only responsible for manipulating the Modifier in the given direction , and calling onFinished at the end. @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = childAnimation ( someAnimator ()) ) { // Omitted code } } fun someAnimator (): ChildAnimator = ChildAnimator { direction : Direction , onFinished : () -> Unit , content : @Composable ( Modifier ) -> Unit -> // Manipulate the Modifier in the given direction and call onFinished at the end } Using childAnimation and childAnimator helper functions. This is the simplest, but less powerful way. The childAnimator function takes care of running the animation. Its block has a very limited responsibility - to render the current frame using the provided factor and direction . @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = childAnimation ( someAnimator ()) ) { // Omitted code } } fun someAnimator (): ChildAnimator = childAnimator { factor : Float , direction : Direction , content : ( Modifier ) -> Unit -> // Render the current frame } Please refer to the predefined animators ( fade , slide , etc.) for implementation examples.","title":"Extensions for Jetpack/JetBrains Compose"},{"location":"extensions/compose/#extensions-for-jetpackjetbrains-compose","text":"Extensions and utilities for easier integration of Decompose with Jetpack/JetBrains Compose.","title":"Extensions for Jetpack/JetBrains Compose"},{"location":"extensions/compose/#setup","text":"Since Jetpack and JetBrains Compose are published separately into different repositories, Decompose provides separate modules for each variant. Both modules provide similar functionality, but you need to choose the corresponding module depending on the used Compose variant.","title":"Setup"},{"location":"extensions/compose/#setup-extensions-for-jetpack-compose","text":"Extensions for Jetpack Compose are provided by the extensions-compose-jetpack module. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" )","title":"Setup extensions for Jetpack Compose"},{"location":"extensions/compose/#setup-extensions-for-jetbrains-compose","text":"Extensions for JetBrains Compose are provided by the extensions-compose-jetbrains module. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" )","title":"Setup extensions for JetBrains Compose"},{"location":"extensions/compose/#content","text":"As mentioned above both modules provide similar functionality. Most of the links in this document refer to the Jetpack module, however there usually a mirror in the JetBrains module.","title":"Content"},{"location":"extensions/compose/#converting-value-to-state","text":"To convert Decompose Value to Compose State use Value<T>.subscribeAsState(): State<T> extensions function: interface SomeComponent { val models : Value < Model > data class Model ( /*...*/ ) } @Composable fun SomeContent ( component : SomeComponent ) { val models : State < Model > by component . models . subscribeAsState () }","title":"Converting Value to State"},{"location":"extensions/compose/#controlling-the-lifecycle-on-desktop","text":"When using JetBrains Compose, you can have a LifecycleRegistry react to changes in the window state using the LifecycleController() composable. This will trigger appropriate lifecycle events when the window is minimized, restored or closed. It is also possible to manually start the lifecycle using LifecycleRegistry.resume() when the instance is created. fun main () { val lifecycle = LifecycleRegistry () val root = RootComponent ( DefaultComponentContext ( lifecycle )) // Alternative: manually start the lifecycle (no reaction to window state) // lifecycle.resume() application { val windowState = rememberWindowState () // Bind the registry to the life cycle of the window LifecycleController ( lifecycle , windowState ) Window ( state = windowState , ...) { // The rest of your content } } } \u26a0\ufe0f When using Compose in desktop platforms, make sure to always use one of the methods above, or your components might not receive lifecycle events correctly.","title":"Controlling the Lifecycle on Desktop"},{"location":"extensions/compose/#navigating-between-composable-components","text":"The Router provides the RouterState as Value<RouterState> which can be observed in a Composable component. This makes it possible to switch child Composable components following the Router . Both Compose extension modules provide the Children(...) function which has the following features: It listens for the RouterState changes and displays the corresponding child Composable component using the provided slot lambda. It preserves components' UI state (e.g. scrolling position) in the back stack and over configuration changes and process death. It animates between children if there is an animation spec provided. Here is an example of switching child components on navigation: // Root interface RootComponent { val routerState : Value < RouterState <* , Child >> sealed class Child { data class Main ( val component : MainComponent ) : Child () data class Details ( val component : DetailsComponent ) : Child () } } @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( rootComponent . routerState ) { when ( val child = it . instance ) { is RootComponent . Child . Main -> MainContent ( child . component ) is RootComponent . Child . Details -> DetailsContent ( child . component ) } } } // Children interface MainComponent interface DetailsComponent @Composable fun MainContent ( profileComponent : MainComponent ) { // Omitted code } @Composable fun DetailsContent ( settingsComponent : DetailsComponent ) { // Omitted code }","title":"Navigating between Composable components"},{"location":"extensions/compose/#animations-experimental","text":"Decompose provides the Child Animation API for Compose, as well as some predefined animation specs. To enable child animations you need to pass the animation argument to the Children function. There are predefined animators provided by Decompose.","title":"Animations (experimental)"},{"location":"extensions/compose/#fade-animation","text":"@Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = childAnimation ( fade ()) ) { // Omitted code } }","title":"Fade animation"},{"location":"extensions/compose/#slide-animation","text":"@Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = childAnimation ( slide ()) ) { // Omitted code } }","title":"Slide animation"},{"location":"extensions/compose/#combining-animators","text":"It is also possible to combine animators using the plus operator. Please note that the order matters - the right animator is applied after the left animator. @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = childAnimation ( fade () + scale ()) ) { // Omitted code } }","title":"Combining animators"},{"location":"extensions/compose/#separate-animations-for-children","text":"Previous examples demonstrate simple cases, when all children have the same animation. But it is also possible to specify separate animations for children. @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = childAnimation { child , direction -> when ( child . instance ) { is RootComponent . Child . Main -> fade () + scale () is RootComponent . Child . Details -> fade () + slide () } } ) { // Omitted code } }","title":"Separate animations for children"},{"location":"extensions/compose/#custom-animations","text":"It is also possible to define custom animations. Implementing ChildAnimation manually. This is the most flexible low-level API. The animation block receives the current RouterState and animates children using the provided content slot. @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = someAnimation () ) { // Omitted code } } fun < C : Any , T : Any > someAnimation (): ChildAnimation < C , T > = ChildAnimation { routerState : RouterState < C , T > , modifier : Modifier , content : @Composable ( Child . Created < C , T > ) -> Unit -> // Render each frame here } Using the childAnimation helper function and implementing ChildAnimator . The childAnimation function takes care of tracking the RouterState changes. ChildAnimator is only responsible for manipulating the Modifier in the given direction , and calling onFinished at the end. @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = childAnimation ( someAnimator ()) ) { // Omitted code } } fun someAnimator (): ChildAnimator = ChildAnimator { direction : Direction , onFinished : () -> Unit , content : @Composable ( Modifier ) -> Unit -> // Manipulate the Modifier in the given direction and call onFinished at the end } Using childAnimation and childAnimator helper functions. This is the simplest, but less powerful way. The childAnimator function takes care of running the animation. Its block has a very limited responsibility - to render the current frame using the provided factor and direction . @Composable fun RootContent ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = childAnimation ( someAnimator ()) ) { // Omitted code } } fun someAnimator (): ChildAnimator = childAnimator { factor : Float , direction : Direction , content : ( Modifier ) -> Unit -> // Render the current frame } Please refer to the predefined animators ( fade , slide , etc.) for implementation examples.","title":"Custom animations"},{"location":"extensions/overview/","text":"Extensions Overview \u00b6 Decompose provides extension modules for various popular libraries and frameworks: Extensions for Jetpack/JetBrains Compose Extensions for Android views","title":"Overview"},{"location":"extensions/overview/#extensions-overview","text":"Decompose provides extension modules for various popular libraries and frameworks: Extensions for Jetpack/JetBrains Compose Extensions for Android views","title":"Extensions Overview"},{"location":"getting-started/contributing/","text":"Contributing \u00b6 Documentation \u00b6 All of the documentation is stored in the docs/ folder of this repository and is all written in markdown. The documentation is generated with Material MkDocs , so if you want to see what the changes look like locally it is recommended to use Docker with the Material MkDocs docker image . # download the image docker pull squidfunk/mkdocs-material # run the server locally docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material Then add the new documentation markdown file into the appropriate folder inside docs/ and add it to the mkdocs.yml file in the project so that it can be navigated to. Put up a pull request for review.","title":"Contributing"},{"location":"getting-started/contributing/#contributing","text":"","title":"Contributing"},{"location":"getting-started/contributing/#documentation","text":"All of the documentation is stored in the docs/ folder of this repository and is all written in markdown. The documentation is generated with Material MkDocs , so if you want to see what the changes look like locally it is recommended to use Docker with the Material MkDocs docker image . # download the image docker pull squidfunk/mkdocs-material # run the server locally docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material Then add the new documentation markdown file into the appropriate folder inside docs/ and add it to the mkdocs.yml file in the project so that it can be navigated to. Put up a pull request for review.","title":"Documentation"},{"location":"getting-started/installation/","text":"Decompose provides a number of modules, they all published to Maven Central Repository. The main Decompose module \u00b6 The main functionality is provided by the decompose module. It contains the core functionality, like Router , ComponentContext , etc. This module supports the following Kotlin Multiplatform targets: android , jvm js (both IR and Legacy modes) iosX64 , iosArm64 tvosArm64 , tvosX64 watchosArm32 , watchosArm64 , watchosX64 macosX64 Gradle setup \u00b6 Groovy implementation \"com.arkivanov.decompose:decompose:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:decompose:<version>\" ) Dependency on Essenty library \u00b6 Some functionality is actually provided by Essenty library. Essenty is implemented by the same author and provides very basic things like Lifecycle , StateKeeper , etc. Most important Essenty modules are added to the decompose module as api dependency, so you don't have to add them manually to your project. Please familiarise yourself with Essenty library. Extensions for Jetpack/JetBrains Compose \u00b6 The Compose UI is currently published in two separate variants: The one developed and maintained by Google is Android only, called Jetpack Compose The Kotlin Multiplatform variant of Jetpack Compose maintained by both JetBrains and Google, we call it JetBrains Compose Due to this fragmentation Decompose provides two separate extension modules for Compose UI: extensions-compose-jetpack - Android library for Jetpack Compose extensions-compose-jetbrains - Kotlin Multiplatform library for JetBrains Compose, supports android and jvm targets Both modules are used to connect Compose UI to Decompose components. Please see the corresponding documentation page . Gradle setup \u00b6 Typically only one module should be selected, depending on the Compose UI variant being used. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" // or implementation \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" ) // or implementation ( \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" ) Extensions for Android views \u00b6 The extensions-android module provides extensions to connect Android views based UI to Decompose components. Please head to the corresponding documentation page for more information. Gradle setup \u00b6 Groovy implementation \"com.arkivanov.decompose:extensions-android:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-android:<version>\" )","title":"Installation"},{"location":"getting-started/installation/#the-main-decompose-module","text":"The main functionality is provided by the decompose module. It contains the core functionality, like Router , ComponentContext , etc. This module supports the following Kotlin Multiplatform targets: android , jvm js (both IR and Legacy modes) iosX64 , iosArm64 tvosArm64 , tvosX64 watchosArm32 , watchosArm64 , watchosX64 macosX64","title":"The main Decompose module"},{"location":"getting-started/installation/#gradle-setup","text":"Groovy implementation \"com.arkivanov.decompose:decompose:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:decompose:<version>\" )","title":"Gradle setup"},{"location":"getting-started/installation/#dependency-on-essenty-library","text":"Some functionality is actually provided by Essenty library. Essenty is implemented by the same author and provides very basic things like Lifecycle , StateKeeper , etc. Most important Essenty modules are added to the decompose module as api dependency, so you don't have to add them manually to your project. Please familiarise yourself with Essenty library.","title":"Dependency on Essenty library"},{"location":"getting-started/installation/#extensions-for-jetpackjetbrains-compose","text":"The Compose UI is currently published in two separate variants: The one developed and maintained by Google is Android only, called Jetpack Compose The Kotlin Multiplatform variant of Jetpack Compose maintained by both JetBrains and Google, we call it JetBrains Compose Due to this fragmentation Decompose provides two separate extension modules for Compose UI: extensions-compose-jetpack - Android library for Jetpack Compose extensions-compose-jetbrains - Kotlin Multiplatform library for JetBrains Compose, supports android and jvm targets Both modules are used to connect Compose UI to Decompose components. Please see the corresponding documentation page .","title":"Extensions for Jetpack/JetBrains Compose"},{"location":"getting-started/installation/#gradle-setup_1","text":"Typically only one module should be selected, depending on the Compose UI variant being used. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" // or implementation \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" ) // or implementation ( \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" )","title":"Gradle setup"},{"location":"getting-started/installation/#extensions-for-android-views","text":"The extensions-android module provides extensions to connect Android views based UI to Decompose components. Please head to the corresponding documentation page for more information.","title":"Extensions for Android views"},{"location":"getting-started/installation/#gradle-setup_2","text":"Groovy implementation \"com.arkivanov.decompose:extensions-android:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-android:<version>\" )","title":"Gradle setup"},{"location":"getting-started/license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and \u00a9 You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"router/browser-history/","text":"Web Browser History \u00b6 By default Router navigation does not affect URLs in the browser address bar. But sometimes it is necessary to have different URLs for different Router destinations. For this purpose Decompose provides an experimental API - WebHistoryController . The controller listens for the Router state changes and updates the browser URL and the history accordingly: When one or more components are pushed to the Router stack, the controller pushes corresponding pages to the history When one or more components are popped from the stack, the controller pops corresponding pages from the history When some components are replaced in the stack, the controller tries its best to keep the page history aligned (there are corner cases) When the user presses the browser's Back button (or selects one of the previous pages in the history dropdown menu), the controller pops the corresponding configurations from the Router When the user navigates forward in the browser history, the controller pushes the corresponding configurations to the Router Corner cases \u00b6 There is one known corner case due to the History API limitations. When all configurations in the stack are replaced with another single configuration ( A <- B <- C ===> D ), the pages corresponding to the second and subsequent removed configurations ( B and C ) remain in the history. If at this point the user will move forward (by clicking on the Forward button in the browser), the previously removed configurations will be pushed back to the stack (the stack will become D <- B or D <- B <- C ). Limitations \u00b6 Only one Router can be attached to an instance of the WebHistoryController . Having multiple instances of the controller is not allowed. Configuring the application \u00b6 Using WebHistoryController in a single page application requires additional configuration - a catch-all strategy to return the same html resource for all paths. This strategy will be different for different server configurations. Development configuration \u00b6 The Kotlin/JS browser target uses webpack-dev-server as a local development server. It can be configured to use the same index.html file (or your primary html file) for all paths, by setting the devServer.historyApiFallback flag. The Gradle DSL for Kotlin webpack currently does not support the historyApiFallback flag, so a special configuration file should be used instead. First, create a directory named webpack.config.d in the JS app module's directory. Then create a new file named devServerConfig.js inside that directory. Finally, put the following content to the file: // <js app module>/webpack.config.d/devServerConfig.js config . devServer = { ... config . devServer , // Merge with other devServer settings \"historyApiFallback\" : true }; Using the WebHistoryController \u00b6 Using WebHistoryController is easy: Create a new instance of WebHistoryController in the JS app and pass it via constructor to a component responsible for navigation (typically it is the root component) In the component, call the WebHistoryController.attach method and supply all arguments In the JS app, pass an initial deeplink to the component Use the deeplink in the component to generate an initial back stack Example \u00b6 The Counter sample demonstrates the use of WebHistoryController : App.kt - demonstrates passing WebHistoryController and a deeplink via constructor to CounterRootComponent CounterRootComponent - demonstrates generating the initial back from the deeplink, as well as calling WebHistoryController.attach and supplying the arguments","title":"Web browser history"},{"location":"router/browser-history/#web-browser-history","text":"By default Router navigation does not affect URLs in the browser address bar. But sometimes it is necessary to have different URLs for different Router destinations. For this purpose Decompose provides an experimental API - WebHistoryController . The controller listens for the Router state changes and updates the browser URL and the history accordingly: When one or more components are pushed to the Router stack, the controller pushes corresponding pages to the history When one or more components are popped from the stack, the controller pops corresponding pages from the history When some components are replaced in the stack, the controller tries its best to keep the page history aligned (there are corner cases) When the user presses the browser's Back button (or selects one of the previous pages in the history dropdown menu), the controller pops the corresponding configurations from the Router When the user navigates forward in the browser history, the controller pushes the corresponding configurations to the Router","title":"Web Browser History"},{"location":"router/browser-history/#corner-cases","text":"There is one known corner case due to the History API limitations. When all configurations in the stack are replaced with another single configuration ( A <- B <- C ===> D ), the pages corresponding to the second and subsequent removed configurations ( B and C ) remain in the history. If at this point the user will move forward (by clicking on the Forward button in the browser), the previously removed configurations will be pushed back to the stack (the stack will become D <- B or D <- B <- C ).","title":"Corner cases"},{"location":"router/browser-history/#limitations","text":"Only one Router can be attached to an instance of the WebHistoryController . Having multiple instances of the controller is not allowed.","title":"Limitations"},{"location":"router/browser-history/#configuring-the-application","text":"Using WebHistoryController in a single page application requires additional configuration - a catch-all strategy to return the same html resource for all paths. This strategy will be different for different server configurations.","title":"Configuring the application"},{"location":"router/browser-history/#development-configuration","text":"The Kotlin/JS browser target uses webpack-dev-server as a local development server. It can be configured to use the same index.html file (or your primary html file) for all paths, by setting the devServer.historyApiFallback flag. The Gradle DSL for Kotlin webpack currently does not support the historyApiFallback flag, so a special configuration file should be used instead. First, create a directory named webpack.config.d in the JS app module's directory. Then create a new file named devServerConfig.js inside that directory. Finally, put the following content to the file: // <js app module>/webpack.config.d/devServerConfig.js config . devServer = { ... config . devServer , // Merge with other devServer settings \"historyApiFallback\" : true };","title":"Development configuration"},{"location":"router/browser-history/#using-the-webhistorycontroller","text":"Using WebHistoryController is easy: Create a new instance of WebHistoryController in the JS app and pass it via constructor to a component responsible for navigation (typically it is the root component) In the component, call the WebHistoryController.attach method and supply all arguments In the JS app, pass an initial deeplink to the component Use the deeplink in the component to generate an initial back stack","title":"Using the WebHistoryController"},{"location":"router/browser-history/#example","text":"The Counter sample demonstrates the use of WebHistoryController : App.kt - demonstrates passing WebHistoryController and a deeplink via constructor to CounterRootComponent CounterRootComponent - demonstrates generating the initial back from the deeplink, as well as calling WebHistoryController.attach and supplying the arguments","title":"Example"},{"location":"router/deeplinking/","text":"Deep linking \u00b6 Users following links on devices have one goal in mind: to get to the content they want to see. Decompose provides ability to override initial destinations and back stack. A typical approach is to parse deep links on the platform side and then pass the initial data to the root component and then down the tree to all the required components. Parsing deep links on the platform side is beyond this documentation. This information should be available in the platform's specific documentation. For example here is the related documentation for Android. Handling deep links \u00b6 Given the basic example from the Router overview page, we can easily handle deep links. Let's say we have a link like http://myitems.com?itemId=3 . When the user clicks on it, we want to open the details screen of the item with the provided id . When the user closes the details screen, they should be navigated back to the list screen. The idea is to pass parsed data from the deep link to a component responsible for navigation, in our case it is the Root component. class RootComponent ( componentContext : ComponentContext , initialItemId : Long? = null ) : Root , ComponentContext by componentContext { private val router = router < Config , Root . Child > ( initialStack = { listOfNotNull ( Config . List , if ( initialItemId != null ) Config . Details ( itemId = initialItemId ) else null , ) }, handleBackButton = true , childFactory = :: createChild ) // Omitted code } Now, if the initialItemId is supplied, the initial screen will be the ItemDetails component. The ItemList component will be in the back stack, so the user will be able to go back.","title":"Deep linking"},{"location":"router/deeplinking/#deep-linking","text":"Users following links on devices have one goal in mind: to get to the content they want to see. Decompose provides ability to override initial destinations and back stack. A typical approach is to parse deep links on the platform side and then pass the initial data to the root component and then down the tree to all the required components. Parsing deep links on the platform side is beyond this documentation. This information should be available in the platform's specific documentation. For example here is the related documentation for Android.","title":"Deep linking"},{"location":"router/deeplinking/#handling-deep-links","text":"Given the basic example from the Router overview page, we can easily handle deep links. Let's say we have a link like http://myitems.com?itemId=3 . When the user clicks on it, we want to open the details screen of the item with the provided id . When the user closes the details screen, they should be navigated back to the list screen. The idea is to pass parsed data from the deep link to a component responsible for navigation, in our case it is the Root component. class RootComponent ( componentContext : ComponentContext , initialItemId : Long? = null ) : Root , ComponentContext by componentContext { private val router = router < Config , Root . Child > ( initialStack = { listOfNotNull ( Config . List , if ( initialItemId != null ) Config . Details ( itemId = initialItemId ) else null , ) }, handleBackButton = true , childFactory = :: createChild ) // Omitted code } Now, if the initialItemId is supplied, the initial screen will be the ItemDetails component. The ItemList component will be in the back stack, so the user will be able to go back.","title":"Handling deep links"},{"location":"router/navigation/","text":"Navigation \u00b6 The Router \u00b6 All navigation in Decompose is done through the Router interface. There is navigate(transformer: (List<C>) -> List<C>, onComplete: (newStack: List<C>, oldStack: List<C>) -> Unit) method with two arguments: transformer - converts the current stack of configurations into a new one. The stack is represented as List , where the last element is the top of the stack, and the first element is the bottom of the stack. onComplete - called when navigation is finished. There is also navigate(transformer: (stack: List<C>) -> List<C>) extension function for convenience, without the onComplete callback. \u26a0\ufe0f The configuration stack returned by the transformer function must not be empty. The navigation process \u00b6 During the navigation process, the Router compares the new stack of configurations with the previous one. The Router ensures that all removed components are destroyed, and that there is only one component resumed at a time - the top one. All components in the back stack are always either stopped or destroyed. The Router usually performs the navigation synchronously, which means that by the time the navigate method returns, the navigation is finished and all component lifecycles are moved into required states. However the navigation is performed asynchronously in case of recursive invocations - e.g. pop is called from onResume lifecycle callback of a component being pushed. All recursive invocations are queued and performed one by one once the current navigation is finished. Router extension functions \u00b6 There are Router extension functions that provide conveniences for navigating, some of which were already used in the router overview example . The preceding examples will utilize the following sealed class & router for showcasing the usage of the Router extensions. sealed class Configuration { object A : Configuration () object B : Configuration () object C : Configuration () object D : Configuration () } val router : Router < Configuration > Push \u00b6 Pushes the provided Configuration at the top of the stack. router . push ( Configuration . B ) router . push ( Configuration . C ) Pop \u00b6 Pops the latest configuration at the top of the stack. router . pop () router . pop { isSuccess -> // Called when the navigation is finished. // isSuccess - `true` if the stack size was greater than 1 and a component was popped, `false` otherwise. } Pop While \u00b6 Drops the configurations at the top of the stack while the provided predicate returns true. router . popWhile { topOfStack : Configuration -> topOfStack !is B } Replace Current \u00b6 Replaces the current configuration at the top of the stack with the provided Configuration . router . replaceCurrent ( Configuration . D ) Bring to Front \u00b6 Removes all components with configurations of the provided Configuration 's class, and adds the provided Configuration to the top of the stack. This is primarily helpful when implementing a Decompose app with bottom navigation Note The operation is performed as one transaction. If there is already a component with the same configuration, it will not be recreated. router . bringToFront ( Configuration . B )","title":"Navigation"},{"location":"router/navigation/#navigation","text":"","title":"Navigation"},{"location":"router/navigation/#the-router","text":"All navigation in Decompose is done through the Router interface. There is navigate(transformer: (List<C>) -> List<C>, onComplete: (newStack: List<C>, oldStack: List<C>) -> Unit) method with two arguments: transformer - converts the current stack of configurations into a new one. The stack is represented as List , where the last element is the top of the stack, and the first element is the bottom of the stack. onComplete - called when navigation is finished. There is also navigate(transformer: (stack: List<C>) -> List<C>) extension function for convenience, without the onComplete callback. \u26a0\ufe0f The configuration stack returned by the transformer function must not be empty.","title":"The Router"},{"location":"router/navigation/#the-navigation-process","text":"During the navigation process, the Router compares the new stack of configurations with the previous one. The Router ensures that all removed components are destroyed, and that there is only one component resumed at a time - the top one. All components in the back stack are always either stopped or destroyed. The Router usually performs the navigation synchronously, which means that by the time the navigate method returns, the navigation is finished and all component lifecycles are moved into required states. However the navigation is performed asynchronously in case of recursive invocations - e.g. pop is called from onResume lifecycle callback of a component being pushed. All recursive invocations are queued and performed one by one once the current navigation is finished.","title":"The navigation process"},{"location":"router/navigation/#router-extension-functions","text":"There are Router extension functions that provide conveniences for navigating, some of which were already used in the router overview example . The preceding examples will utilize the following sealed class & router for showcasing the usage of the Router extensions. sealed class Configuration { object A : Configuration () object B : Configuration () object C : Configuration () object D : Configuration () } val router : Router < Configuration >","title":"Router extension functions"},{"location":"router/navigation/#push","text":"Pushes the provided Configuration at the top of the stack. router . push ( Configuration . B ) router . push ( Configuration . C )","title":"Push"},{"location":"router/navigation/#pop","text":"Pops the latest configuration at the top of the stack. router . pop () router . pop { isSuccess -> // Called when the navigation is finished. // isSuccess - `true` if the stack size was greater than 1 and a component was popped, `false` otherwise. }","title":"Pop"},{"location":"router/navigation/#pop-while","text":"Drops the configurations at the top of the stack while the provided predicate returns true. router . popWhile { topOfStack : Configuration -> topOfStack !is B }","title":"Pop While"},{"location":"router/navigation/#replace-current","text":"Replaces the current configuration at the top of the stack with the provided Configuration . router . replaceCurrent ( Configuration . D )","title":"Replace Current"},{"location":"router/navigation/#bring-to-front","text":"Removes all components with configurations of the provided Configuration 's class, and adds the provided Configuration to the top of the stack. This is primarily helpful when implementing a Decompose app with bottom navigation Note The operation is performed as one transaction. If there is already a component with the same configuration, it will not be recreated. router . bringToFront ( Configuration . B )","title":"Bring to Front"},{"location":"router/overview/","text":"Router Overview \u00b6 The Router \u00b6 A key unit is Router . It is responsible for managing components, just like FragmentManager . The Router supports back stack and so each component has its own Lifecycle . Each time a new component is pushed, the currently active component is stopped. When a component is popped from the back stack, the previous component is resumed. This allows business logic to run while the component is in the back stack. The Router has a state consisting of a currently active component and a back stack, so it can be rendered as any other state. Child components can also have Routers (nested navigation), and each component can have more than one Router . Component Configurations \u00b6 Each component created and managed by the Router has its Configuration . It is just a class with all the data required for the component instantiation. Configurations must meet the following requirements: Be immutable Correctly implement equals() and hashCode() methods Be unique (by equality) in the Router stack Implement Parcelable interface Configurations are the keys \u00b6 Each Configuration is a unique key of a component. The Router uses Configurations to check what components should be alive and what should be destroyed. On the client side, Configurations allow you to instantiate components with proper input parameters. For convenience and safety, you may define your Configurations as data class , and use only val properties and immutable data structures. Configurations are Parcelable \u00b6 Configurations can be persisted via Android's saved state , thus allowing back stack restoration after configurations change or process death. When the back stack is restored, only currently active components are recreated. All others in the back stack remain destroyed, and recreated on demand when navigating back. Decompose uses Essenty library, which provides both Parcelable interface and @Parcelize annotation in common code using expect/actual, which works well with Kotlin Multiplatform. Please familiarise yourself with Essenty library. \u26a0\ufe0f On Android the amount of data that can be preserved is limited . Please take care of the Configuration sizes. Routing example \u00b6 Here is a very basic example of navigation between two child components: // ItemList component interface ItemList { // Omitted code fun onItemClicked ( id : Long ) } class ItemListComponent ( componentContext : ComponentContext , private val onItemSelected : ( id : Long ) -> Unit ) : ItemList , ComponentContext by componentContext { // Omitted code override fun onItemClicked ( id : Long ) { onItemSelected ( id ) } } // ItemDetails component interface ItemDetails { // Omitted code fun onCloseClicked () } class ItemDetailsComponent ( componentContext : ComponentContext , itemId : Long , private val onFinished : () -> Unit ) : ItemDetails , ComponentContext by componentContext { // Omitted code override fun onCloseClicked () { onFinished () } } // Root component interface Root { val routerState : Value < RouterState <* , Child >> sealed class Child { class List ( val component : ItemList ) : Child () class Details ( val component : ItemDetails ) : Child () } } class RootComponent ( componentContext : ComponentContext ) : Root , ComponentContext by componentContext { private val router = router < Config , Root . Child > ( initialConfiguration = Config . List , handleBackButton = true , // Pop the back stack on back button press childFactory = :: createChild ) override val routerState : Value < RouterState <* , Root . Child >> = router . state private fun createChild ( config : Config , componentContext : ComponentContext ): Root . Child = when ( config ) { is Config . List -> Root . Child . List ( itemList ( componentContext )) is Config . Details -> Root . Child . Details ( itemDetails ( componentContext , config )) } private fun itemList ( componentContext : ComponentContext ): ItemList = ItemListComponent ( componentContext = componentContext , onItemSelected = { router . push ( Config . Details ( itemId = it )) } ) private fun itemDetails ( componentContext : ComponentContext , config : Config . Details ): ItemDetails = ItemDetailsComponent ( componentContext = componentContext , itemId = config . itemId , onFinished = router :: pop ) private sealed class Config : Parcelable { @Parcelize object List : Config () @Parcelize data class Details ( val itemId : Long ) : Config () } } Multiple routers in a component \u00b6 When multiple Routers are required in one component, each such a Router must have a unique key associated. The keys are required to be unique only within the component, so it is ok for different components to have Routers with same keys. An exception will be thrown if multiple Routers with same key are detected in a component. class Root ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val topRouter = router < TopConfig , TopChild > ( key = \"TopRouter\" , // Omitted code ) private val bottomRouter = router < BottomConfig , BottomChild > ( key = \"BottomRouter\" , // Omitted code ) }","title":"Overview"},{"location":"router/overview/#router-overview","text":"","title":"Router Overview"},{"location":"router/overview/#the-router","text":"A key unit is Router . It is responsible for managing components, just like FragmentManager . The Router supports back stack and so each component has its own Lifecycle . Each time a new component is pushed, the currently active component is stopped. When a component is popped from the back stack, the previous component is resumed. This allows business logic to run while the component is in the back stack. The Router has a state consisting of a currently active component and a back stack, so it can be rendered as any other state. Child components can also have Routers (nested navigation), and each component can have more than one Router .","title":"The Router"},{"location":"router/overview/#component-configurations","text":"Each component created and managed by the Router has its Configuration . It is just a class with all the data required for the component instantiation. Configurations must meet the following requirements: Be immutable Correctly implement equals() and hashCode() methods Be unique (by equality) in the Router stack Implement Parcelable interface","title":"Component Configurations"},{"location":"router/overview/#configurations-are-the-keys","text":"Each Configuration is a unique key of a component. The Router uses Configurations to check what components should be alive and what should be destroyed. On the client side, Configurations allow you to instantiate components with proper input parameters. For convenience and safety, you may define your Configurations as data class , and use only val properties and immutable data structures.","title":"Configurations are the keys"},{"location":"router/overview/#configurations-are-parcelable","text":"Configurations can be persisted via Android's saved state , thus allowing back stack restoration after configurations change or process death. When the back stack is restored, only currently active components are recreated. All others in the back stack remain destroyed, and recreated on demand when navigating back. Decompose uses Essenty library, which provides both Parcelable interface and @Parcelize annotation in common code using expect/actual, which works well with Kotlin Multiplatform. Please familiarise yourself with Essenty library. \u26a0\ufe0f On Android the amount of data that can be preserved is limited . Please take care of the Configuration sizes.","title":"Configurations are Parcelable"},{"location":"router/overview/#routing-example","text":"Here is a very basic example of navigation between two child components: // ItemList component interface ItemList { // Omitted code fun onItemClicked ( id : Long ) } class ItemListComponent ( componentContext : ComponentContext , private val onItemSelected : ( id : Long ) -> Unit ) : ItemList , ComponentContext by componentContext { // Omitted code override fun onItemClicked ( id : Long ) { onItemSelected ( id ) } } // ItemDetails component interface ItemDetails { // Omitted code fun onCloseClicked () } class ItemDetailsComponent ( componentContext : ComponentContext , itemId : Long , private val onFinished : () -> Unit ) : ItemDetails , ComponentContext by componentContext { // Omitted code override fun onCloseClicked () { onFinished () } } // Root component interface Root { val routerState : Value < RouterState <* , Child >> sealed class Child { class List ( val component : ItemList ) : Child () class Details ( val component : ItemDetails ) : Child () } } class RootComponent ( componentContext : ComponentContext ) : Root , ComponentContext by componentContext { private val router = router < Config , Root . Child > ( initialConfiguration = Config . List , handleBackButton = true , // Pop the back stack on back button press childFactory = :: createChild ) override val routerState : Value < RouterState <* , Root . Child >> = router . state private fun createChild ( config : Config , componentContext : ComponentContext ): Root . Child = when ( config ) { is Config . List -> Root . Child . List ( itemList ( componentContext )) is Config . Details -> Root . Child . Details ( itemDetails ( componentContext , config )) } private fun itemList ( componentContext : ComponentContext ): ItemList = ItemListComponent ( componentContext = componentContext , onItemSelected = { router . push ( Config . Details ( itemId = it )) } ) private fun itemDetails ( componentContext : ComponentContext , config : Config . Details ): ItemDetails = ItemDetailsComponent ( componentContext = componentContext , itemId = config . itemId , onFinished = router :: pop ) private sealed class Config : Parcelable { @Parcelize object List : Config () @Parcelize data class Details ( val itemId : Long ) : Config () } }","title":"Routing example"},{"location":"router/overview/#multiple-routers-in-a-component","text":"When multiple Routers are required in one component, each such a Router must have a unique key associated. The keys are required to be unique only within the component, so it is ok for different components to have Routers with same keys. An exception will be thrown if multiple Routers with same key are detected in a component. class Root ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val topRouter = router < TopConfig , TopChild > ( key = \"TopRouter\" , // Omitted code ) private val bottomRouter = router < BottomConfig , BottomChild > ( key = \"BottomRouter\" , // Omitted code ) }","title":"Multiple routers in a component"}]}